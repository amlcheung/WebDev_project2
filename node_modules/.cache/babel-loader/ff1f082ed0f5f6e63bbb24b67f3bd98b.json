{"ast":null,"code":"'use strict';\n\nvar fs = require('fs'),\n    StringDecoder = require('string_decoder').StringDecoder;\n\nfunction createLineReader(readStream, options, creationCb) {\n  if (options instanceof Function) {\n    creationCb = options;\n    options = undefined;\n  }\n\n  if (!options) options = {};\n  var encoding = options.encoding || 'utf8',\n      separator = options.separator || /\\r\\n?|\\n/,\n      bufferSize = options.bufferSize || 1024,\n      bufferStr = '',\n      decoder = new StringDecoder(encoding),\n      closed = false,\n      eof = false,\n      separatorIndex = -1,\n      separatorLen,\n      readDefer,\n      moreToRead = false,\n      findSeparator;\n\n  if (separator instanceof RegExp) {\n    findSeparator = function () {\n      var result = separator.exec(bufferStr);\n\n      if (result && (result.index + result[0].length < bufferStr.length || eof)) {\n        separatorIndex = result.index;\n        separatorLen = result[0].length;\n      } else {\n        separatorIndex = -1;\n        separatorLen = 0;\n      }\n    };\n  } else {\n    separatorLen = separator.length;\n\n    findSeparator = function () {\n      separatorIndex = bufferStr.indexOf(separator);\n    };\n  }\n\n  function getReadStream() {\n    return readStream;\n  }\n\n  function close(cb) {\n    if (!closed) {\n      closed = true;\n\n      if (typeof readStream.close == 'function') {\n        readStream.close();\n      }\n\n      setImmediate(cb);\n    }\n  }\n\n  function onFailure(err) {\n    close(function (err2) {\n      return creationCb(err || err2);\n    });\n  }\n\n  function isOpen() {\n    return !closed;\n  }\n\n  function isClosed() {\n    return closed;\n  }\n\n  function waitForMoreToRead(cb) {\n    if (moreToRead) {\n      cb();\n    } else {\n      readDefer = cb;\n    }\n  }\n\n  function resumeDeferredRead() {\n    if (readDefer) {\n      readDefer();\n      readDefer = null;\n    }\n  }\n\n  function read(cb) {\n    waitForMoreToRead(function () {\n      var chunk;\n\n      try {\n        chunk = readStream.read(bufferSize);\n      } catch (err) {\n        cb(err);\n      }\n\n      if (chunk) {\n        bufferStr += decoder.write(chunk.slice(0, chunk.length));\n      } else {\n        moreToRead = false;\n      }\n\n      cb();\n    });\n  }\n\n  function onStreamReadable() {\n    moreToRead = true;\n    resumeDeferredRead();\n  }\n\n  function onStreamEnd() {\n    eof = true;\n    resumeDeferredRead();\n  }\n\n  readStream.on('readable', onStreamReadable);\n  readStream.on('end', onStreamEnd);\n  readStream.on('error', onFailure);\n\n  function shouldReadMore() {\n    findSeparator();\n    return separatorIndex < 0 && !eof;\n  }\n\n  function callWhile(conditionFn, bodyFn, doneCallback) {\n    if (conditionFn()) {\n      bodyFn(function (err) {\n        if (err) {\n          doneCallback(err);\n        } else {\n          setImmediate(callWhile, conditionFn, bodyFn, doneCallback);\n        }\n      });\n    } else {\n      doneCallback();\n    }\n  }\n\n  function readToSeparator(cb) {\n    callWhile(shouldReadMore, read, cb);\n  }\n\n  function hasNextLine() {\n    return bufferStr.length > 0 || !eof;\n  }\n\n  function nextLine(cb) {\n    if (closed) {\n      return cb(new Error('LineReader has been closed'));\n    }\n\n    function getLine(err) {\n      if (err) {\n        return cb(err);\n      }\n\n      if (separatorIndex < 0 && eof) {\n        separatorIndex = bufferStr.length;\n      }\n\n      var ret = bufferStr.substring(0, separatorIndex);\n      bufferStr = bufferStr.substring(separatorIndex + separatorLen);\n      separatorIndex = -1;\n      cb(undefined, ret);\n    }\n\n    findSeparator();\n\n    if (separatorIndex < 0) {\n      if (eof) {\n        if (hasNextLine()) {\n          separatorIndex = bufferStr.length;\n          getLine();\n        } else {\n          return cb(new Error('No more lines to read.'));\n        }\n      } else {\n        readToSeparator(getLine);\n      }\n    } else {\n      getLine();\n    }\n  }\n\n  readToSeparator(function (err) {\n    if (err) {\n      onFailure(err);\n    } else {\n      return creationCb(undefined, {\n        hasNextLine: hasNextLine,\n        nextLine: nextLine,\n        close: close,\n        isOpen: isOpen,\n        isClosed: isClosed,\n        getReadStream: getReadStream\n      });\n    }\n  });\n}\n\nfunction open(filenameOrStream, options, cb) {\n  if (options instanceof Function) {\n    cb = options;\n    options = undefined;\n  }\n\n  var readStream;\n\n  if (typeof filenameOrStream.read == 'function') {\n    readStream = filenameOrStream;\n  } else if (typeof filenameOrStream === 'string' || filenameOrStream instanceof String) {\n    readStream = fs.createReadStream(filenameOrStream);\n  } else {\n    cb(new Error('Invalid file argument for LineReader.open.  Must be filename or stream.'));\n    return;\n  }\n\n  readStream.pause();\n  createLineReader(readStream, options, cb);\n}\n\nfunction eachLine(filename, options, iteratee, cb) {\n  if (options instanceof Function) {\n    cb = iteratee;\n    iteratee = options;\n    options = undefined;\n  }\n\n  var asyncIteratee = iteratee.length === 3;\n  var theReader;\n  var getReaderCb;\n  open(filename, options, function (err, reader) {\n    theReader = reader;\n\n    if (getReaderCb) {\n      getReaderCb(reader);\n    }\n\n    if (err) {\n      if (cb) cb(err);\n      return;\n    }\n\n    function finish(err) {\n      reader.close(function (err2) {\n        if (cb) cb(err || err2);\n      });\n    }\n\n    function newRead() {\n      if (reader.hasNextLine()) {\n        setImmediate(readNext);\n      } else {\n        finish();\n      }\n    }\n\n    function continueCb(continueReading) {\n      if (continueReading !== false) {\n        newRead();\n      } else {\n        finish();\n      }\n    }\n\n    function readNext() {\n      reader.nextLine(function (err, line) {\n        if (err) {\n          finish(err);\n        }\n\n        var last = !reader.hasNextLine();\n\n        if (asyncIteratee) {\n          iteratee(line, last, continueCb);\n        } else {\n          if (iteratee(line, last) !== false) {\n            newRead();\n          } else {\n            finish();\n          }\n        }\n      });\n    }\n\n    newRead();\n  }); // this hook is only for the sake of testing; if you choose to use it,\n  // please don't file any issues (unless you can also reproduce them without\n  // using this).\n\n  return {\n    getReader: function (cb) {\n      if (theReader) {\n        cb(theReader);\n      } else {\n        getReaderCb = cb;\n      }\n    }\n  };\n}\n\nmodule.exports.open = open;\nmodule.exports.eachLine = eachLine;","map":{"version":3,"sources":["/Users/madeleinevanzuylen/Desktop/WebDev_project2/node_modules/line-reader/lib/line_reader.js"],"names":["fs","require","StringDecoder","createLineReader","readStream","options","creationCb","Function","undefined","encoding","separator","bufferSize","bufferStr","decoder","closed","eof","separatorIndex","separatorLen","readDefer","moreToRead","findSeparator","RegExp","result","exec","index","length","indexOf","getReadStream","close","cb","setImmediate","onFailure","err","err2","isOpen","isClosed","waitForMoreToRead","resumeDeferredRead","read","chunk","write","slice","onStreamReadable","onStreamEnd","on","shouldReadMore","callWhile","conditionFn","bodyFn","doneCallback","readToSeparator","hasNextLine","nextLine","Error","getLine","ret","substring","open","filenameOrStream","String","createReadStream","pause","eachLine","filename","iteratee","asyncIteratee","theReader","getReaderCb","reader","finish","newRead","readNext","continueCb","continueReading","line","last","getReader","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar fs = require('fs'),\n    StringDecoder = require('string_decoder').StringDecoder;\n\nfunction createLineReader(readStream, options, creationCb) {\n  if (options instanceof Function) {\n    creationCb = options;\n    options = undefined;\n  }\n  if (!options) options = {};\n\n  var encoding = options.encoding || 'utf8',\n      separator = options.separator || /\\r\\n?|\\n/,\n      bufferSize = options.bufferSize || 1024,\n      bufferStr = '',\n      decoder = new StringDecoder(encoding),\n      closed = false,\n      eof = false,\n      separatorIndex = -1,\n      separatorLen,\n      readDefer,\n      moreToRead = false,\n      findSeparator;\n\n  if (separator instanceof RegExp) {\n    findSeparator = function() {\n      var result = separator.exec(bufferStr);\n      if (result && (result.index + result[0].length < bufferStr.length || eof)) {\n        separatorIndex = result.index;\n        separatorLen = result[0].length;\n      } else {\n        separatorIndex = -1;\n        separatorLen = 0;\n      }\n    };\n  } else {\n    separatorLen = separator.length;\n    findSeparator = function() {\n      separatorIndex = bufferStr.indexOf(separator);\n    };\n  }\n\n  function getReadStream() {\n    return readStream;\n  }\n\n  function close(cb) {\n    if (!closed) {\n      closed = true;\n      if (typeof readStream.close == 'function') {\n        readStream.close();\n      }\n      setImmediate(cb);\n    }\n  }\n\n  function onFailure(err) {\n    close(function(err2) {\n      return creationCb(err || err2);\n    });\n  }\n\n  function isOpen() {\n    return !closed;\n  }\n\n  function isClosed() {\n    return closed;\n  }\n\n  function waitForMoreToRead(cb) {\n    if (moreToRead) {\n      cb();\n    } else {\n      readDefer = cb;\n    }\n  }\n\n  function resumeDeferredRead() {\n    if (readDefer) {\n      readDefer();\n      readDefer = null;\n    }\n  }\n\n  function read(cb) {\n    waitForMoreToRead(function() {\n      var chunk;\n\n      try {\n        chunk = readStream.read(bufferSize);\n      } catch (err) {\n        cb(err);\n      }\n\n      if (chunk) {\n        bufferStr += decoder.write(chunk.slice(0, chunk.length));\n      } else {\n        moreToRead = false;\n      }\n\n      cb();\n    });\n  }\n\n  function onStreamReadable() {\n    moreToRead = true;\n    resumeDeferredRead();\n  }\n\n  function onStreamEnd() {\n    eof = true;\n    resumeDeferredRead();\n  }\n\n  readStream.on('readable', onStreamReadable);\n  readStream.on('end', onStreamEnd);\n  readStream.on('error', onFailure);\n\n  function shouldReadMore() {\n    findSeparator();\n\n    return separatorIndex < 0 && !eof;\n  }\n\n  function callWhile(conditionFn, bodyFn, doneCallback) {\n    if (conditionFn()) {\n      bodyFn(function (err) {\n        if (err) {\n          doneCallback(err);\n        } else {\n          setImmediate(callWhile, conditionFn, bodyFn, doneCallback);\n        }\n      });\n    } else {\n      doneCallback();\n    }\n  }\n\n  function readToSeparator(cb) {\n    callWhile(shouldReadMore, read, cb);\n  }\n\n  function hasNextLine() {\n    return bufferStr.length > 0 || !eof;\n  }\n\n  function nextLine(cb) {\n    if (closed) {\n      return cb(new Error('LineReader has been closed'));\n    }\n\n    function getLine(err) {\n      if (err) {\n        return cb(err);\n      }\n\n      if (separatorIndex < 0 && eof) {\n        separatorIndex = bufferStr.length;\n      }\n      var ret = bufferStr.substring(0, separatorIndex);\n\n      bufferStr = bufferStr.substring(separatorIndex + separatorLen);\n      separatorIndex = -1;\n      cb(undefined, ret);\n    }\n\n    findSeparator();\n\n    if (separatorIndex < 0) {\n      if (eof) {\n        if (hasNextLine()) {\n          separatorIndex = bufferStr.length;\n          getLine();\n        } else {\n          return cb(new Error('No more lines to read.'));\n        }\n      } else {\n        readToSeparator(getLine);\n      }\n    } else {\n      getLine();\n    }\n  }\n\n  readToSeparator(function(err) {\n    if (err) {\n      onFailure(err);\n    } else {\n      return creationCb(undefined, {\n        hasNextLine: hasNextLine,\n        nextLine: nextLine,\n        close: close,\n        isOpen: isOpen,\n        isClosed: isClosed,\n        getReadStream: getReadStream\n      });\n    }\n  });\n}\n\nfunction open(filenameOrStream, options, cb) {\n  if (options instanceof Function) {\n    cb = options;\n    options = undefined;\n  }\n\n  var readStream;\n\n  if (typeof filenameOrStream.read == 'function') {\n    readStream = filenameOrStream;\n  } else if (typeof filenameOrStream === 'string' || filenameOrStream instanceof String) {\n    readStream = fs.createReadStream(filenameOrStream);\n  } else {\n    cb(new Error('Invalid file argument for LineReader.open.  Must be filename or stream.'));\n    return;\n  }\n\n  readStream.pause();\n  createLineReader(readStream, options, cb);\n}\n\nfunction eachLine(filename, options, iteratee, cb) {\n  if (options instanceof Function) {\n    cb = iteratee;\n    iteratee = options;\n    options = undefined;\n  }\n  var asyncIteratee = iteratee.length === 3;\n\n  var theReader;\n  var getReaderCb;\n\n  open(filename, options, function(err, reader) {\n    theReader = reader;\n    if (getReaderCb) {\n      getReaderCb(reader);\n    }\n\n    if (err) {\n      if (cb) cb(err);\n      return;\n    }\n\n    function finish(err) {\n      reader.close(function(err2) {\n        if (cb) cb(err || err2);\n      });\n    }\n\n    function newRead() {\n      if (reader.hasNextLine()) {\n        setImmediate(readNext);\n      } else {\n        finish();\n      }\n    }\n\n    function continueCb(continueReading) {\n      if (continueReading !== false) {\n        newRead();\n      } else {\n        finish();\n      }\n    }\n\n    function readNext() {\n      reader.nextLine(function(err, line) {\n        if (err) {\n          finish(err);\n        }\n\n        var last = !reader.hasNextLine();\n\n        if (asyncIteratee) {\n          iteratee(line, last, continueCb);\n        } else {\n          if (iteratee(line, last) !== false) {\n            newRead();\n          } else {\n            finish();\n          }\n        }\n      });\n    }\n\n    newRead();\n  });\n\n  // this hook is only for the sake of testing; if you choose to use it,\n  // please don't file any issues (unless you can also reproduce them without\n  // using this).\n  return {\n    getReader: function(cb) {\n      if (theReader) {\n        cb(theReader);\n      } else {\n        getReaderCb = cb;\n      }\n    }\n  };\n}\n\nmodule.exports.open = open;\nmodule.exports.eachLine = eachLine;\n"]},"metadata":{},"sourceType":"script"}